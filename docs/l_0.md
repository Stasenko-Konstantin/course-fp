# Введение

“The programmers of tomorrow are the wizards of the future.
You're going to look like you have magic powers compared to
everyone else.” <br>
Гейб Ньюэлл - основатель Valve

“The programs we use to conjure processes are like a
sorcerer's spells. They are carefully composed from symbolic
expressions in arcane and esoteric programming languages.” <br>
Гарольд Абельсон и Джеральд Джей Сассман, Стуктура и Интерпретация Компьютерных Программ

---

Перед тем как мы приступим к "скучным" теоретезированиям и рассмотрениям практической стороны вопроса
хотелось бы сказать пару слов, поделиться своим мнением так сказать. Для меня функциональное
программирование это что-то необычное, можно даже сказать волшебное. И не для меня одного
на самом деле. Одна из главных книг по ФП и Computer Science - SICP, имеет в качестве обложки
следующую [иллюстрацию](https://github.com/cat-milk/Anime-Girls-Holding-Programming-Books/tree/master/SICP):

![](img/l_0/1.jpg)

которая наглядно демонстрирует то как воспринимается ФП в целом и Lisp в частности.
Я хочу чтобы этот учебный материал стал для вас входом в этот интересный
функциональный мир (или правильней сказать [страну](http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)).
Новый взгляд на решение программистских задач и проблем может дать вам практическую альтернативу тому к чему вы уже
привыкли.  Это может испортить вас. Однажды взглянув на вещи через функциональную призму
вы уже не сможете просто так вернуться к другим языкам, не требуя от них той же гибкости в которой вы теперь нуждаетесь.

---

Впрочем, покончим с сантиментами и приступим уже к делу. Пробежимся кратко по сухой и скучноватой части
и займемся чем поинтересней. Начать думаю стоит с истории - истоками
ФП принято считать изобретение Алонзо Черчем в 30-х годах прошлого века формальной системы
именуемой [лямбда-исчислением (λ-calculus)](https://ru.wikipedia.org/wiki/%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Оно предназначено для формализации и анализа понятия вычислимости, ровно как
и Машина Тьюринга. Оба эти формализма легли в основу языков программирования и
используемых ими парадигм. Так Машина Тьюринга представляет собой
императивную парадигму, а лямбда-исчисление - функциональную.
<br>
<br>
Существует множество вариаций лямбда-исчисления, но в базе своей
оно про анонимные функции, т.е. лямбды. В общем виде
они выглядят так:
```
λx.xy
```
что эквивалентно следующей конструкции языка Python:
```python
lambda x: x(y)
```
Как мы видим символ `λ` заменили на `lambda`, вместо
`.` используется `:`, а применение функции требует
круглых скобок. Помимо синтаксических различий тут
также можно увидеть одну интересную семантическую деталь -
наша анонимная функция принимает в качестве параметра
другую функцию, это и называется функциями высших порядков (ФВП).
А такие объекты которые мы можем также свободно использовать,
как и остальные, более привычные нам, как например числа и строки,
называются объектами или гражданами первого класса, или
первоклассными объектами. Это все более подробно мы обсудим позже.
В Clojure же это будет так:
```clojure
(fn [x] (x y))
```
[//]: # (Todo: перепиши)
Это общая форма и конкретно в этом примере Rust вероятнее всего попросит вас уточнить
типы (об этом позже). Сперва указывается список формальных параметров, затем
тело лямбда-функции. Rust обладает одной интересной особенностью: блоки кода
интерпретируются как выражения. Это позволяет использовать более сложные конструкции чем в 
том же Python, к примеру мы можем переделать предыдущий сниппет так, чтобы `x` вызывался дважды:
```clojure
(fn [x]
    (x y)
    (x y))
```
В Python такое написать не получиться просто из-за самого устройства лямбд в Python.
Правда в Python есть свои [приколы](https://buttondown.email/hillelwayne/archive/i-am-disappointed-by-dynamic-typing/), более могущественные, но и более вербозные.
Вышеописанная особенность позволяет писать более функциональный код и может использоваться 
и в других сценариях, к примеру:
```clojure
;; clojure
(defn calculate-and-print
      [x]
      (println (if (zero? (mod x 2)) 
                 "четное" 
                 "нечетное")))
```
```python
# python
def calculate_and_print(x):
    if x%2 == 0:
        print("четное")
    else:
        print("нечетное")
```

[//]: # (Todo: перепиши, напиши про выражения)
Все из-за того что блоки кода `{ ... }`, как я уже писал выше, являются выражениями, т.е.
вычисляются во что-то. Например `1+1` является выражением, оно вычислится в `2`, `{ 1+1 }`
также вычислится 2, а `println!("hello");` уже ни во что не вычислится (на самом деле в Rust
это будет [Unit-тип](https://doc.rust-lang.org/std/primitive.unit.html) 
единственным значением которого является `()`, по сути это такой
функциональный аналог `void` из С-подобных языков) 

---

Первым языком программирования был
создан Fortran - язык для научных вычислений который применяется до сих пор.
Вторым же языком программирования стал [Lisp](https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF). 
Эти два языка очень сильно отличались друг от друга, но они оба сильно повлияли на
будущее как языков программирования, так и самого программирования в целом.
Так например именно в Lisp`е впервые реализовали такие вещи как:
динамическая типизация, сборка мусора, REPL, замыкания и пр.
Многие вещи в которых Lisp стал первопроходцем легли в основу
не только функциональных языков, но и многих других и уже
привычны нам, осталось только научиться ими пользоваться.
<br>
<br>
Еще одной важной вехой в истории ФП можно считать появление
в 1990 году такого языка программирования как [Haskell](https://ru.wikipedia.org/wiki/Haskell).
Он был создан специальным комитетом, чтобы объединить разрозненные
на тот момент идеи ФП в одном языке и развивать их уже более
централизованно. Т.е. можно сказать что Haskell это своего рода
лаборатория по изучению и исследованию всевозможных теорий
из таких областей как: ФП, теория языков программирования, компиляторостроение.
Этот язык оказал огромное влияние на последующие исследования в этих областях.
<br>
<br>
На данный момент существует явная тенденция - большинство популярных и наиболее используемых языков
программирования стремится к мультипарадигмальнности и чистых языков сейчас почти не найти. Даже такие консервативные языки как
C++ и Java внедряют в свои новые версии элементы ФП, а в C# и вовсе существует встроенный язык запросов (eDSL)
под названием LINQ который позволяет писать элегантный и надежный код в функциональном стиле. 
Rust же и вовсе сочетает в себе лучшие качества таких системных языков как C и C++ и функциональных языков
семейства ML (SML, Ocaml, Haskell и пр.), он на протяжении уже нескольких лет подряд является
любимым языком среди разработчиков по версии [Stackoverflow](https://survey.stackoverflow.co/2022/#most-loved-dreaded-and-wanted-language-love-dread).
Что еще примечательно, 2-е и 3-е места в этом рейтинге занимают функциональные языки Elixir и Clojure (диалект Lisp'а).
Поэтому если вы хотите стать более лучшими, профессиональными, а главное счастливыми программистами, то вы там где нужно! <br>

Успехов!