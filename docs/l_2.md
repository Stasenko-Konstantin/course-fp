# Первые шаги - функции

Так как мы в данном курсе рассматриваем функциональное программирование, то думаю стоит начать
с того, на чем оно непосредственно основывается - с функций. Для чего предназначены функции?
Обычно с их помощью избавляются от дублирующего кода. Когда вы видите в коде
несколько кусков делающих одно и то же, но с разными данными, то вы можете
абстрагироваться по этим данным сделав их параметрами функции и таким образом избавиться
от дублирования. Кто-то может спросить - а что плохого в дублировании? Отвечаю - дублирование делает код
более хрупким и ненадежным. Есть даже целый принцип в программировании под названием
[DRY (Don't Repeat Yourself)](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself). В качестве примера такой
абстракции приведу следующий синтетический
сниппет:

```python
list1 = [1, 2, 3]
result1 = 0
for i in list1:
    result1 += i

list2 = [4, 5, 6]
result2 = 0
for i in list2:
    result2 += 1
```

Если вдруг мы захотим к примеру выводить каждое суммируемое число, то нам нужно будет
изменить два места:

```python
list1 = [1, 2, 3]
result1 = 0
for i in list1:
    print(i)  # 1
    result1 += i

list2 = [4, 5, 6]
result2 = 0
for i in list2:
    print(i)  # 2
    result2 += 1
```

А если таких мест в программе много, то можно легко ошибиться и забыть про одно из них, тогда
в вашем коде будет неприятная логическая ошибка. Чтобы избавиться от подобных потенциальных ошибок и
просто-напросто облегчить нам самим жизнь, мы создаем следующую функцию:

```python
def sum(list):
    result = 0
    for i in list:
        result += i
    return result
```

А теперь уберем из изначального варианта циклы и заменим их вызовом только что написанной функции `sum`:

```python
list1 = [1, 2, 3]
result1 = sum(list1)

list2 = [4, 5, 6]
result2 = sum(list2)
```

Теперь, чтобы добавить отладочный вывод, нам требуется изменить лишь одно место в программе:

```python
def sum(list):
    result = 0
    for i in list:
        print(i)  # 1
        result += i
    return result
```

---
Мы увидели как на практике использовать функции, теперь давайте немного разберемся с теорией.
Функция - стрелка, морфизм, черный ящик преобразующий значение *a* в значение *b*.
Можно представить следующим образом: `a -> b`. На самом деле это обобщенная запись 
функционального типа в языке Haskell:
```haskell
f :: a -> b
```
Что читается как *функция из а в b*. Это базовое описание практически любой функции.
В дальнейшем мы увидим более сложные и интересные примеры, но все они будут основываться и 
отсылаться к `a -> b`. Теперь давайте посмотрим на функции более предметно.
Я не буду приводить грамматики описывающие синтаксис, вместо этого приведу
немного более наглядный, но достаточно абстрактный пример синтаксиса функций в Python:

```python
def f(param1, param2, ..., paramn):
    ...
    return expr
```

Отсюда можно выделить следующие ключевые моменты:

- Всякая функция должна начинаться с ключевого слова `def`.
- Затем идет имя функции (в примере это `f`).
- После имени, в круглых скобках через запятую перечисляются параметры принимаемые функцией.
- `:`,
- после которого идет тело функции. Оно может содержать произвольный код на Python'е.
- Чтобы вернуть некоторый результат, требуется использовать конструкцию `return` (опционально).

Функции в Python могут быть и сложнее чем то что описано выше, например могут использоваться
глобальные параметры (`global`), `*args, **kwargs`, аннотации типов, декораторы, async/await и пр.
Но для нас сейчас это все несущественно. Теперь давайте сравним это с Rust:

```rust
fn f(param1: T1, param2: T2, ..., paramn: Tn) -> R { expr }
```

Где:

- Ключевое слово для объявления функции - `fn`.
- Параметры функции имеют тип (T1, T2, ..., Tn).
- Функция возвращает значение типа R.
- В функциях необязательно указывать ключевое слово return.

О типах мы поговорим позже.

Чтобы лучше прочувствовать вкус Rust я приведу несколько более конкретный пример:

```python
# python
def sum(n):
    sum = 0
    for i in range(0, n + 1):
        sum += i
    return sum
```

```rust
// rust
fn sum(n: i32) -> i32 {
    let mut sum = 0;
    for i in 0..n {
        sum += i;
    }
    sum // или return sum;
}
# fn main() {
    # println!("sum(10)");
    # println!("{}", sum(10));
    #
}
```
