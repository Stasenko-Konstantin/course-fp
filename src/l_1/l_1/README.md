# Пробуем Racket на вкус

Пара слов о Racket. Если вы открывали ссылку на википедию с главной страницы курса, то знаете
что Racket - динамически типизированный, мультипарадигмальный язык программирования.
Несмотря на поддержку разных парадигм, как и во многих других языках в Racket преобладает только одна,
в данном случае функциональная. Также это диалект диалекта Lisp, что сильно сказывается на всем дизайне 
языка, начиная от очевидно повсеместных круглых скобок для структурирования кода, заканчивая мощной макросистемой
и общим подходом к построению программ.

В начале изучения какого-либо языка первым дело традиционно демонстрируют Hello World, т.е. минимально
работающую программу. По сути вы уже видели ее на скриншоте в предыдущем уроке - `'hello-world`.
Это называется *символом*. Символы - специальный тип данных, значения которых возвращают сами себя.
Что это значит? Давайте посмотрим более наглядно - запустим REPL введя `racket` в консоли, или запустив
DrRacket, затем введем `'hello-world`, в ответ нам вернется то же самое, т.е. `'hello-world`.
Для сравнения введем какое-нибудь арифметическое выражения, например 1 + 2, в Racket это будет
выглядеть как `(+ 1 2)` (это называется префиксной нотацией, ее рассмотрим чуть позже). В общем виде
ваша работа с REPL должна выглядеть как-то так:

```racket
> 'hello-world
'hello-world
> (+ 1 2)
3
```

В Python'е это выглядело бы примерно так:

```python
>>> "hello-world"
'hello-world'
>>> 1 + 2
3
```

В Python'е нет символьного типа данных, поэтому пришлось воспользоваться строковым литералом.
Для тех кто не знаком с понятием литерала, литерал - представление значения определенного типа в исходном
коде. Если ввести `hello-world` в вызове `print(input())`, то это не будет литералом. 

Racket различает символьный и строковый типы данных. Если коротко, то символы эффективней, а строки
удобней и выразительней. Я думаю вы уже знаете для чего используются строки. Символы же могут использоваться
для создания легковесных перечислений, к примеру можно создать перечисление месяцев воспользовавшись списками 
(они также подробнее будут рассмотрены позднее):

```racket
> (list 'декабрь 'январь 'февраль)
'(декабрь январь февраль)
```

Тут уже заметны некоторые интересные моменты, попробуйте помедитировать над этим примером, поиграть с ним.

```python
>>> ["декабрь", "январь", "февраль"]
['декабрь', 'январь', 'февраль']
```

Теперь давайте разберемся с префиксной нотацией. Как вы уже заметили что те же арифметические выражения
в Racket'е выглядят иначе чем в том же Python, в котором используется инфиксная форма. Все дело в
устройстве самого Racket'а - практически весь код в нем представлен списками. По началу это кажется
странным и неудобным, но у этого есть свои бонусы, например кодом можно манипулировать также как и 
обычными данными, так как код на Racket просто набор списков. Т.е. это примерно как если бы мы писали
на Python как-то так:

```python
[def, add, (n1, n2), 
    return, n1, +, n2]
```

```racket
(define (add n1 n2)
  (+ n1 n2))
```

И так как это обычный Python'овский список, то и делать с ним мы можем все то же самое что и с другими
списками. Помимо этого префиксная запись избавляет нас от запоминания приоритетов, так как все однозначно
определяется расстановкой скобок. А также позволяет писать следующим образом:

```racket
> (+ 1 2 3 4 5 6 7 8 9)
45
```

```python
>>> 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9
45
```

Надеюсь вам удалось прочувствовать вкус Racket'а.

И если вы успешно дошли до этого момента, то могу вас поздравить - вы готовы учиться ФП!

<details>
  <summary>Упражнения</summary>
  1. Переведите следующее арифметическое выражение в префиксную форму: 1+5-10*4+7+3 <br>
  

</details>

[в начало урока](../README.md)
<br>
[содержание](../../../README.md)
<br>
[назад](../l_0/README.md)
<br>
[дальше](../../l_2/README.md)