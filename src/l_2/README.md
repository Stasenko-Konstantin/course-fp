# Первые шаги - функции
Так как мы в данном курсе рассматриваем функциональное программирование, то думаю стоит начать
с того, на чем оно непосредственно основывается - с функций. Для чего предназначены функции?
Обычно с их помощью избавляются от дублирующего кода. Когда вы видите в коде 
несколько кусков делающих одно и то же, но с разными данными, то вы можете
абстрагироваться по этим данным сделав их параметрами функции и таким образом избавиться
от дублирования. Кто-то может спросить - а что плохого в дублировании? Отвечаю - дублирование делает код
более хрупким и ненадежным. Есть даже целый принцип в программировании под названием 
[DRY (Don't Repeat Yourself)](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself). В качестве примера такой абстракции приведу следующий синтетический
сниппет:
```python
list1 = [1, 2, 3]
result1 = 0
for i in list1:
    result1 += i
    
list2 = [4, 5, 6]
result2 = 0
for i in list2:
    result2 += 1
```
Если вдруг мы захотим к примеру выводить каждое суммируемое число, то нам нужно будет
изменить два места:
```python
list1 = [1, 2, 3]
result1 = 0
for i in list1:
    print(i)
    result1 += i
    
list2 = [4, 5, 6]
result2 = 0
for i in list2:
    print(i)
    result2 += 1
```
А если таких мест в программе много, то можно легко ошибиться и забыть про одно из них, тогда
в вашем коде будет неприятная логическая ошибка. Чтобы избавиться от подобных потенциальных ошибок и
просто-напросто облегчить нам самим жизнь, мы создаем следующую функцию:
```python
def sum(list):
    result = 0
    for i in list:
        result += i
    return result
```
А теперь уберем из изначального варианта циклы и заменим их вызовом только что написанной функции `sum`:
```python
list1 = [1, 2, 3]
result1 = sum(list1)
    
list2 = [4, 5, 6]
result2 = sum(list2)
```
Теперь, чтобы добавить отладочный вывод, нам требуется изменить лишь одно место в программе:
```python
def sum(list):
    result = 0
    for i in list:
        print(i)
        result += i
    return result
```
---
Мы увидели как на практике использовать функции, теперь давайте немного разберемся с теорией.
Я не буду приводить грамматики описывающие синтаксис, вместо этого приведу
немного более наглядный, но достаточно абстрактный пример синтаксиса функций в Python:
```python
def f(param1, param2, ..., paramn):
    ...
    return result
```
Отсюда можно выделить следующие ключевые моменты:
- Всякая функция должна начинаться с ключевого слова `def`.
- Затем идет имя функции (в примере это `f`).
- После имени, в круглых скобках через запятую перечисляются параметры принимаемые функцией.
- `:`,
- после которого идет тело функции. Оно может содержать произвольный код на Python'е.
- Чтобы вернуть некоторый результат, требуется использовать конструкцию `return` (опционально).

Функции в Python могут быть и сложнее чем то что описано выше, например могут использоваться
глобальные параметры (`global`), `*args, **kwargs`, аннотации типов, декораторы, async/await и пр. 
Но для нас сейчас это все несущественно. Теперь давайте сравним это с Racket:
```racket
(define (f param1 param2 ... paramn)
    (expr))
```
Где:
- Вся функция оборачивается в круглые скобки.
- Ключевое слово для объявления функции немного длиннее - `define` которое в принципе означает связывание имени со 
значением, т.е. применимо не только для функций.
- После объявления связывания в скобках, через пробел указываются имя функции и ее параметры.
- Отсутствует конструкция `return`, а в качестве возвращаемого значения используется последнее выражение (всегда).

Чтобы лучше прочувствовать вкус Racket я приведу несколько более конкретный пример:
```python
# python
def sum(n):
    sum = 0
    for i in range(0, n+1):
        sum += i
    return sum
```
```racket
; racket
(define (sum n)
  (let ([sum 0])
    (for ([i (range (+ n 1))])
      (set! sum (+ sum i)))
    sum))
```
Такой код получился при буквальном переводе с языка на язык, такое на самом деле не приветствуется не только
в естественных языках. В дальнейшем мы будем постепенно изменять (рефакторить) эту функцию делая ее
более идиоматичной (подходящей для конкретного языка/подхода).

Обратите внимание на предпоследнюю строку, точнее на функцию `set!`. Она используется для переприсваивания
значения переменной. Знак `!` не просто так содержится в ее имени, он указывает на то что функция создает побочный 
эффект во время своей работы. Тема побочных эффектов подробнее будет раскрыта позже, пока стоит лишь запомнить 
что такие функции рекомендуется использовать как можно реже.

Еще раз посмотрите на код. Возможно в нем вас пугает обилие скобочек, но это дело привычки на самом деле, при правильном 
форматировании на скобочки почти не обращаешь внимания и код на Racket читается не хуже чем код на Python. К тому же такой 
синтаксис оправдан, он дает некоторые [интересные особенности](https://ru.wikipedia.org/wiki/%D0%93%D0%BE%D0%BC%D0%BE%D0%B8%D0%BA%D0%BE%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C) 
благодаря которым мы можем лепить из такого языка практически все что нам угодно.

---

В одном из предыдущих уроков я рассказывал про анонимные функции, давайте вспомним как они пишутся в
Python:
```python
lambda param1, param2, ..., paramn: expr
```
Что мы видим здесь:
- Лямбда объявляется с помощью ключевого слова `lambda`,
- после которого идет список параметров.
- `:`,
- за которым идет тело лямбды.

Также считаю важным отметить тот момент, что лямбды в Python ограничены, в них нельзя указывать произвольное 
кол-во выражений. Давайте теперь сравним с Racket:
```racket
(lambda (param1 param2 ... paramn) expr1 expr2 ... exprn)
; или
(λ (param1 param2 ... paramn) expr1 expr2 ... exprn)
```
Тут также используется ключевое слово lambda (или символ лямбда - λ). После в скобках указывается
список параметров. И наконец тело функции. В отличие от Python, Racket позволяет написать например следующий код:
```racket
(λ (x)
  (displayln (* x 10))
  (+ x 1))
```
~~Правда в Python есть свои [приколы](https://buttondown.email/hillelwayne/archive/i-am-disappointed-by-dynamic-typing/), более могущественные, но и более вербозные.~~

[содержание](../../README.md)
<br>
[назад](../l_1/l_1/README.md)
<br>
[дальше](../l_3/README.md)